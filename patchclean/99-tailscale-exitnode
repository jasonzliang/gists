#!/bin/sh /etc/rc.common
# Tailscale Exit Node Auto-Configuration Init Script
#
# This script automatically configures and monitors a Tailscale exit node on OpenWrt.
# Features:
# - Proper OpenWrt init script with start/stop/restart functionality
# - Interactive subnet route configuration with sensible defaults
# - Sets up hourly monitoring via cron to ensure exit node stays enabled
# - Manages Tailscale service startup and connection verification
# - Preserves configuration across reboots and upgrades
#
# Installation:
#   cp script.sh /etc/init.d/tailscale-exitnode
#   chmod +x /etc/init.d/tailscale-exitnode
#   /etc/init.d/tailscale-exitnode enable
#
# Usage:
#   /etc/init.d/tailscale-exitnode start     # Start and configure exit node
#   /etc/init.d/tailscale-exitnode stop      # Stop exit node
#   /etc/init.d/tailscale-exitnode restart   # Restart exit node
#   /etc/init.d/tailscale-exitnode check     # Check/enable exit node status
#   /etc/init.d/tailscale-exitnode routes    # Show current route configuration
#   /etc/init.d/tailscale-exitnode reconfigure # Reconfigure advertised routes
#   /etc/init.d/tailscale-exitnode setup     # Interactive setup

START=99
STOP=10
USE_PROCD=1

SCRIPT_NAME="tailscale-exitnode"
SCRIPT_PATH="/etc/init.d/$SCRIPT_NAME"
ROUTES_FILE="/etc/tailscale-custom-routes"
PIDFILE="/var/run/tailscale-exitnode.pid"
DEFAULT_ROUTES="0.0.0.0/0,::/0"

# Logging helper
log() { logger -t tailscale_exitnode "$1"; }

# File operations helper
ensure_file() {
    local file="$1" content="$2" mode="$3"
    if [ ! -f "$file" ]; then
        local temp_file="${file}.tmp.$$"
        if printf "$content" > "$temp_file" && mv "$temp_file" "$file"; then
            [ "$mode" ] && chmod "$mode" "$file"
        else
            rm -f "$temp_file"
            return 1
        fi
    fi
}

# Service management helper
manage_service() {
    local service="$1" action="$2"
    [ -x "/etc/init.d/$service" ] && "/etc/init.d/$service" "$action" 2>/dev/null
}

# Check if service is running
is_running() {
    case "$1" in
        cron) pgrep -x crond >/dev/null || pgrep -x cron >/dev/null ;;
        tailscaled) pgrep tailscaled >/dev/null ;;
        *) pgrep "$1" >/dev/null ;;
    esac
}

# Setup alias in .ashrc and ensure .profile sources .ashrc
setup_alias() {
    local ashrc="/root/.ashrc"
    local profile="/root/.profile"
    local alias_line="alias exitnode=\"$SCRIPT_PATH check\""
    local source_line="[ -f ~/.ashrc ] && . ~/.ashrc"

    # Add alias to .ashrc
    if [ ! -f "$ashrc" ] || ! grep -qF "alias exitnode=" "$ashrc"; then
        echo "$alias_line" >> "$ashrc"
        log "Added exitnode alias to $ashrc"
    fi

    # Ensure .profile sources .ashrc
    if [ ! -f "$profile" ] || ! grep -qF ". ~/.ashrc" "$profile"; then
        echo "$source_line" >> "$profile"
        log "Added .ashrc sourcing to $profile"
    fi
}

# Interactive route configuration
configure_routes() {
    cat <<'EOF'

=== Tailscale Route Configuration ===
Default routes: 0.0.0.0/0,::/0 (all internet traffic)

Do you want to advertise additional subnet routes? (y/N)
EOF
    printf "Choice: "; read -r choice

    case "${choice:-n}" in
        [Yy]*)
            cat <<'EOF'

Enter additional IP ranges (comma-separated):
Examples: 192.168.1.0/24 or 10.0.0.0/8,172.16.0.0/12

EOF
            printf "Additional routes: "; read -r extra
            echo "${DEFAULT_ROUTES}${extra:+,$extra}" > "$ROUTES_FILE"
            echo "✓ Custom routes saved"
            ;;
        *)
            echo "$DEFAULT_ROUTES" > "$ROUTES_FILE"
            echo "✓ Using default routes only"
            ;;
    esac
}

# Setup cron with service check
setup_cron() {
    # Enable cron service
    if [ -x /etc/init.d/cron ]; then
        manage_service cron enabled || manage_service cron enable
        is_running "cron" || manage_service cron start
    else
        log "Cron service not available"
        return 1
    fi

    # Add cron job if not exists
    local current_cron temp_cron
    current_cron=$(crontab -l 2>/dev/null || true)

    if ! echo "$current_cron" | grep -qF "$SCRIPT_PATH check"; then
        temp_cron="/tmp/crontab.$$"
        {
            echo "$current_cron"
            echo "# Tailscale exit node check"
            echo "0 * * * * $SCRIPT_PATH check"
        } > "$temp_cron"

        if crontab "$temp_cron"; then
            log "Added hourly cron job"
        else
            log "Failed to update crontab"
            rm -f "$temp_cron"
            return 1
        fi
        rm -f "$temp_cron"
    fi
}

# Setup upgrade preservation
setup_preservation() {
    local conf_file
    if [ -d /etc/sysupgrade.conf.d ]; then
        conf_file="/etc/sysupgrade.conf.d/tailscale-exitnode"
    elif [ -f /etc/sysupgrade.conf ]; then
        conf_file="/etc/sysupgrade.conf"
    fi

    [ "$conf_file" ] && {
        # Preserve the script, routes file, and alias files
        for file in "$SCRIPT_PATH" "$ROUTES_FILE" "/root/.ashrc" "/root/.profile"; do
            grep -q "^$file$" "$conf_file" 2>/dev/null || echo "$file" >> "$conf_file"
        done
    }
}

# Main Tailscale exit node check and configuration
check_tailscale() {
    # Verify Tailscale installation and service
    command -v tailscale >/dev/null || { log "Tailscale not installed"; return 1; }
    command -v jsonfilter >/dev/null || { log "jsonfilter not available"; return 1; }

    # Start tailscale service if not running
    if ! is_running tailscaled; then
        log "Starting Tailscale daemon"
        manage_service tailscale start
        sleep 5
    fi

    # Get status and check exit node
    local status exitnode_enabled routes
    status=$(tailscale status --json 2>/dev/null) || { log "Failed to get status"; return 1; }
    exitnode_enabled=$(echo "$status" | jsonfilter -e '$.Self.ExitNodeOption' 2>/dev/null)

    if [ "$exitnode_enabled" != "true" ]; then
        routes=$([ -f "$ROUTES_FILE" ] && cat "$ROUTES_FILE" || echo "$DEFAULT_ROUTES")
        # Validate routes format
        case "$routes" in
            *[!0-9./,:]*) log "Invalid routes format: $routes"; return 1 ;;
            *\ *) log "Routes cannot contain spaces: $routes"; return 1 ;;
        esac
        log "Enabling exit node with routes: $routes"
        tailscale up --advertise-exit-node --accept-dns=true --accept-routes --advertise-routes="$routes"
        log "Exit node enabled"
    else
        log "Exit node already enabled"
    fi

    # Create pidfile to indicate service is running
    echo $$ > "$PIDFILE"
}

# OpenWrt init script functions
start_service() {
    log "Starting Tailscale exit node service"

    # Ensure routes file exists with defaults
    [ ! -f "$ROUTES_FILE" ] && echo "$DEFAULT_ROUTES" > "$ROUTES_FILE"

    # Configure and start exit node
    check_tailscale

    # Use procd to monitor the service
    procd_open_instance
    procd_set_param command /bin/sh -c "while [ -f '$PIDFILE' ]; do sleep 300; $SCRIPT_PATH check; done"
    procd_set_param pidfile "$PIDFILE"
    procd_set_param respawn ${respawn_threshold:-3600} ${respawn_timeout:-5} ${respawn_retry:-5}
    procd_close_instance
}

stop_service() {
    log "Stopping Tailscale exit node service"

    # Remove pidfile to stop monitoring loop
    rm -f "$PIDFILE"

    # Optionally disconnect tailscale (uncomment if desired)
    # tailscale down
}

restart() {
    stop
    sleep 2
    start
}

# Additional commands
check() {
    check_tailscale
}

reconfigure() {
    configure_routes
    echo "Routes reconfigured. Run '/etc/init.d/$SCRIPT_NAME restart' to apply"
}

routes() {
    echo "Current routes: $([ -f "$ROUTES_FILE" ] && cat "$ROUTES_FILE" || echo "$DEFAULT_ROUTES")"
}

setup() {
    echo "=== Tailscale Exit Node Setup ==="

    # Check if already enabled
    if [ -f /etc/rc.d/S${START}${SCRIPT_NAME} ]; then
        echo "✓ Service already enabled"
    else
        echo "Enabling service..."
        "$SCRIPT_PATH" enable
    fi

    configure_routes
    setup_cron
    setup_preservation
    setup_alias

    echo "✓ Setup completed"
    echo ""
    echo "Usage:"
    echo "  /etc/init.d/$SCRIPT_NAME start     # Start exit node"
    echo "  /etc/init.d/$SCRIPT_NAME stop      # Stop exit node"
    echo "  /etc/init.d/$SCRIPT_NAME restart   # Restart exit node"
    echo "  /etc/init.d/$SCRIPT_NAME check     # Check status"
    echo "  exitnode                           # Alias for check command"
    echo ""
    echo "Starting service..."
    "$SCRIPT_PATH" start
}

# Handle additional commands
EXTRA_COMMANDS="check reconfigure routes setup"
EXTRA_HELP="        check           Check and enable exit node if needed
        reconfigure     Reconfigure advertised routes
        routes          Show current route configuration
        setup           Interactive setup and configuration"

# Route commands to appropriate functions
case "$1" in
    check) check ;;
    reconfigure) reconfigure ;;
    routes) routes ;;
    setup) setup ;;
esac